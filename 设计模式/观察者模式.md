## 观察者模式 (Observer)

> 当一个对象状态发生改变时，依赖它的对象会自动收到通知，并且自动更新，实现了低耦合，非侵入式通知与修改机制。

### 传统写法
```php
<?php 
class Event
{
    function trigger()
    {
        //传统写法事件触发需要写 很多很多代码，改变需求也只能在事件体中修改
        // 逻辑一
        // 逻辑二
        // 逻辑三
        // ......
    }
}
```
### 观察者模式

```php
<?php
//首先的有个事件产生和事件通知的类，这个事件绑定，通知不能随便被修改。
abstract class EventGenerator
{
    //存储所有的观察者对象
    private $observers = [];

    //增加观察者,传入参数必须是一个对象
    function addObserver(Observer $observer)
    {
        $this->observers[] = $observer;
    }

    //通知观察者
    function notice()
    {
        foreach ($this->observers as $observer) {
            $observer->update();
        }
    }
}
```


```php
<?php
//需要有一个统一所有事件的接口
interface Observer
{
    //这个接口只需要修改信息
    function update($eventInfo = null);
}
```

```php
<?php
//实现一个观察者类一
class Observer1 implements Observer
{
    function update($eventInfo = null)
    {
        echo '观察者一';
    }
}
//实现一个观察者类二
class Observer2 implements Observer
{
    function update($eventInfo = null)
    {
        echo '观察者二';
    }
}
```




```php
<?php
//事件实际发生者，继承事件处理类
class Event extends EventGenerator
{
    //被外部调用的唯一事件
    function trigger()
    {
        $this->notice();
    }
}
```

```php
<?php
//外部调用
$event = new Event();
$event->addObserver(new Observer1);//添加观察者
$event->addObserver(new Observer2);//添加观察者
$event->trigger();//调用事件

//输出
// 观察者一
// 观察者二
```

> 这里 Observer1 Observer2 就是两个观察者，他们各自实现了接口规定的 update 方法，在触发时执行 update
。事件类 Event 做了两件事情，1.继承 事件处理类 EventGenerator 2.暴露一个对外的事件方法
trigger。外部调用的时候首先 添加了两个观察者 Observer1 Observer2，然后执行了 事件方法 trigger。trigger 方法里面
调用了事件处理类的 notice 方法，notice 方法就会通知 被添加到 存储 对象的 $observers 属性中所有的对象对应的的方法，而这个方法就是 update 方法。

> 这里面有一个接口 Observer 是为了更好的管理 所有观察者需要执行的最终方法，定义了一个 update 那么每一个继承 的观察者都必须要实现 update,在 事件处理类通知的时候也会遵循这个接口规定 update 
,实现了两端统一，更加规范。

> 实际例子中，会员达成不同的成就需要发放不同的优惠券。1.设置不同的观察者，不同会员发不同券，2.事件处理中心，观察者添加，通知。3.事件执行方法。
在会员达成成就前，添加一个观察者。触发事件后 通知 观察者该发券了。
