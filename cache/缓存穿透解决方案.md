### 正确的使用缓存数据库

#### 见一下一段取出缓存中的数据代码
```php
<?php
function getList($key)
{
    $data = $this->get($key);//查询缓存
    if (!empty($data)) {
        return $data;
    }
    $data = $this->getDb();//没有查询到缓存，从数据库中获取
    $redis->set($key,$data,$time);//设置缓存
    return $data;
}
```
> 以上代码初看感觉没什么毛病，仔细看一下提出一下几个问题。

* 没有缓存穿透解决方案。
* 缓存过期会有多个请求到数据库

#### 如何解决了？
```php
<?php
$data = $this->get($key);//查询缓存
if (!is_null($data)) {
    return $data;
}
$data = $this->getDb();//没有查询到缓存，从数据库中获取
//如果缓存穿透后，数据库中没查询到数据，自定义数据，写入缓存
if (empty($data)) {
    $data = [];
}
$redis->set($key,$data);
return $data;
```
> 以上代码避免了所有请求穿透缓存到达数据库。

#### 在缓存失效只想要一个请求到数据库中？
```php
<?php
$data = $this->get($key);//查询缓存
if (!is_null($data)) {
    //缓存未过期，返回数据
    if ($data['expireTime']>time()) {
        return $data['data'];
    }
    //缓存已过期，获取锁,如果未获取到锁，则返回过期数据
    if (!$redis->setNx()) {
        return $data['data'];
    }
}
$list = $this->getDb();//从数据库中获取

if (empty($list)) {
    $list  = [];
}
$expireTime = 120;//缓存时间为 120秒
//设置过期时间
$data = [
    'data'=>$data,
    'expireTime'=>$expireTime - 60
];
$redis->set($key,$data,$expireTime);
return $list;
```
> 以上方案可以解决缓存穿透，避免雪崩效应，加上锁机制，到达数据库的请求只有一个。
* 关于过期时间，使用我们自己的过期时间操作缓存数据有更大的灵活空间。缓存时间比我们业务定义的过期时间晚 60秒。这样，我们有60秒的时间刷新最新的数据到缓存数据库中。
